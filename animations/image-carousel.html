<!DOCTYPE html>
<html lang="en">
<head>
    <style>


/* CUSTOMIZE THE CAROUSEL
-------------------------------------------------- */

/* Carousel base class */
.carousel { 
  height: 300px;
  margin-bottom: 60px;
}
/* Since positioning the image, we need to help out the caption */
.carousel-caption {
  z-index: 10;
}

/* Declare heights because of positioning of img element */
.carousel .item {
  height: 300px;
  background-color: #777;
}
.carousel-inner > .item > img {
  position: absolute;
  top: 0;
  left: 0;
  min-width: 100%;
  height: 300px;
}
* RESPONSIVE CSS
-------------------------------------------------- */

@media (min-width: 768px) {
 
  /* Bump up size of carousel content */
  .carousel-caption p {
    margin-bottom: 20px;
    font-size: 21px;
    line-height: 1.4;
  }

}

    </style>
  >
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="myCarousel" class="carousel slide" data-ride="carousel">
        <!-- Indicators -->
        <ol class="carousel-indicators">
          <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
          <li data-target="#myCarousel" data-slide-to="1"></li>
          <li data-target="#myCarousel" data-slide-to="2"></li>
        </ol>
        <div class="carousel-inner" role="listbox">
          <div class="item active">
            <img class="first-slide" src="data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="First slide">
            <div class="container">
              <div class="carousel-caption">
                <h1>Example headline.</h1>
                <p>Note: If you're viewing this page via a <code>file://</code> URL, the "next" and "previous" Glyphicon buttons on the left and right might not load/display properly due to web browser security rules.</p>
                <p><a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a></p>
              </div>
              </div>
          </div>
          <div class="item">
            <img class="second-slide" src="data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
            <div class="container">
              <div class="carousel-caption">
                <h1>Another example headline.</h1>
                <p>Cras justo odio, dapibus ac facilisis in, egestas eget quam. Donec id elit non mi porta gravida at eget metus. Nullam id dolor id nibh ultricies vehicula ut id elit.</p>
                <p><a class="btn btn-lg btn-primary" href="#" role="button">Learn more</a></p>
              </div>
            </div>
          </div>
          <div class="item"> 
            <img class="third-slide" src="data:image/gif;base64,R0lGODlhAQABAIAAAHd3dwAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Third slide">
            <div class="container">
              <div class="carousel-caption">
                <h1>One more for good measure.</h1>
                <p>Cras justo odio, dapibus ac facilisis in, egestas eget quam. Donec id elit non mi porta gravida at eget metus. Nullam id dolor id nibh ultricies vehicula ut id elit.</p>
                <p><a class="btn btn-lg btn-primary" href="#" role="button">Browse gallery</a></p>
              </div>
            </div>
          </div>
        </div>
        <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
          <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
          <span class="sr-only">Previous</span>
        </a>
        <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
          <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
          <span class="sr-only">Next</span>
        </a>
      </div><!-- /.carousel -->
      <script>
        heroCarouselProp = {
                infiniteMode: true,
                enableFlicking: true,
                alwaysShowControls: true,
                startItemIndex: 0,
                animationDuration: 400,
                onStageCallback: function(onStageItem) {
                  // execute your code here
                }
              }
        
        var mycarousel = {
          init: function() {
        
            if ($('#myCarousel').length > 0 && $('#myCarousel div.item').length > 1) {
              this.heroCarousel();
              
            }
          },
          heroCarousel: function() {
            // Home page carousel - BOOTSTRAP Carousel
            $(this.heroCarouselHandler).carousel(this.defaults);
        
            // bind swipe getures
            //  this.bindSwipeEvent($(this.heroCarouselHandler));
            this.determineCarouselMode();
        
            //bind carousel events
            this.bindEvents();
          },
          /**
           * binds the touch gestures to the carousel to enable 
           * flicking and cover all user interaction
           */
          bindTouchInteraction: function() {
            var self = this;
            this.carouselList
              .on('touchstart', function(e) {
                self.handleTouchStart(self, e.originalEvent);
              })
              .on('touchmove', function(e) {
                self.handleTouchMove(self, e.originalEvent);
              })
              .on('touchend', function(e) {
                self.handleTouchEnd(self, e.originalEvent);
              })
              .on('touchcancel', function(e) {
                //on cancel we do as well the finishing move ;)
                self.handleTouchEnd(self, e.originalEvent);
              })
              .on('tap click', 'li a', function(e) {
                if (!$(this).closest("li").hasClass(self.options.onStageClass)) {
                  e.preventDefault();
                }
              });
        
          },
        
          /**
           * handling the touch start event
           * initialise all necessary parameters
           */
          handleTouchStart: function(self, e) {
            if (self.isMoving) {
              e.preventDefault();
              return false;
            }
        
            self.touchStartX = e.touches[0].pageX;
            self.touchStartY = e.touches[0].pageY;
            self.touchStartTime = (new Date()).getTime();
            // saving a epic reference for touch-end comparison
            self.touchEpicStartTime = self.touchStartTime;
            self.touchEpicStartX = self.touchCurrentX = self.touchStartX;
            self.touchEpicStartY = self.touchCurrentY = self.touchStartY;
          },
        
          /**
           * handling the touch move event
           * update the affected parameters
           */
          handleTouchMove: function(self, e) {
        
            self.touchCurrentX = e.touches[0].pageX;
            self.touchCurrentY = e.touches[0].pageY;
            self.touchCurrentTime = (new Date()).getTime();
        
            self.distanceX = self.touchCurrentX - self.touchStartX;
            self.distanceY = self.touchCurrentY - self.touchStartY;
        
            self.horizontalFlick = (Math.abs(self.distanceX) > Math.abs(self.distanceY));
        
            if (self.horizontalFlick && !self.isVerticalScrolling) {
              e.preventDefault();
              // reset position hooks
              self.touchStartX = self.touchCurrentX;
              self.touchStartY = self.touchCurrentY;
        
              // moving the carousel along the movement
              self.carouselPos += self.distanceX;
              // cover speed attacks so the carousel never runs out of its boundaries
              self.carouselPos = (self.carouselPos > self.minCarouselPos) ? self.minCarouselPos : self.carouselPos;
              self.carouselPos = (self.carouselPos < self.maxCarouselPos) ? self.maxCarouselPos : self.carouselPos;
        
              var crouselPosition = ($("html").attr("dir") && $("html").attr("dir") === "rtl") ? {
                right: self.carouselPos
              } : {
                left: self.carouselPos
              };
              self.carouselList.css(crouselPosition);
            } else {
              self.isVerticalScrolling = true;
            }
          },
        
          /**
           * handling the touch end event
           * finish all bounded actions and clean up
           */
          handleTouchEnd: function(self, e) {
            var closestToStageItemIndex, movedX, movedY;
        
            // if we have encountered only a tiny flick we help the user moving on to the next item
            movedX = self.touchEpicStartX - self.touchCurrentX;
            movedY = self.touchEpicStartY - self.touchCurrentY;
            closestToStageItemIndex = self.onStageItemIndex;
            if (!self.isVerticalScrolling && Math.abs(movedX) > 20) {
              closestToStageItemIndex = (movedX < 0) ? (self.onStageItemIndex - 1) : (self.onStageItemIndex + 1);
            }
            // protect carousels from overflowing the items stack
            if (!self.options.infiniteMode) {
              closestToStageItemIndex = (closestToStageItemIndex < self.itemsCount) ? closestToStageItemIndex : self.itemsCount;
            }
        
            // animate to snap perfectly on stage
            self.moveTo(closestToStageItemIndex, self.options.animationDuration, true);
        
          
        
            self.isVerticalScrolling = false;
        
            // being a good kid - cleaning up
            self.touchStartX = 0;
            self.touchStartY = 0;
            self.touchCurrentX = 0;
            self.touchCurrentY = 0;
            self.distanceX = 0;
            self.distanceY = 0;
            self.touchEpicStartX = 0;
            self.touchEpicStartY = 0;
          },
        
          /**
           * check how to interact with the carousel - using touch
           * gestures like flicking or the common scroll control-links
           */
          determineInteraction: function() {
              //multiple item mode
            if (heroCarouselProp.enableFlicking) {
              this.bindTouchInteraction();
        
              // if we wanna flick only, so hide the disturbing controls
              if (!this.options.alwaysShowControls) {
                this.hideCarouselControls();
              }
            }
        
            if (this.options.alwaysShowControls || !this.options.enableFlicking) {
              // get the carousel controls to work
              this.bindCarouselControls();
            }
          },
        
          /**
           * check which elements and which options have been set and
           * determine the appropriate carousel mode
           */
          determineCarouselMode: function() {
            
            // determine the appropriate behaviour based on the item count
            itemsCount = $('#myCarousel div.item').length ;
            if (itemsCount > 1) {
        
              // check how to interact with the carousel (-items)
              this.determineInteraction();
        
              // check how to behave when reaching the edge elements (first/last)
              this.bindEdgeBehaviour();
        
            } else {
              // single item mode
              // this.hideCarouselControls();
            }
        
            // set stage context parameters
            this.setStageContext();
          },
        
          /**
           * calculate the new carousel position based on the passed
           * target item's index
           * 
           * @param {integer} zero based index of the target item
           */
          calculateCarouselPosition: function(ix) {
            return (this.stageWidth * ix * (-1));
          },
        
          /**
           * move to the specified item (zero based index)
           * this can be done immediately or animated based on the parameter
           * 
           *  @param {integer} zero based index of the target item
           *  @param {integer} duration in ms for the animation
           *  @param {boolean} flag to determine an (non-)animated start
           */
          moveTo: function(targetItemIndex, animDuration, doAnimation) {
            var self = this,
              newPos = this.calculateCarouselPosition(targetItemIndex);
        
            // we don't put effort in already staged elements
            if (targetItemIndex === this.onStageItemIndex && this.carouselPos === newPos) {
              return;
            }
        
            if (isNaN(animDuration)) {
              //animDuration = self.options.animationDuration;
              animDuration = 400;
            }
        
            // validating that we have a boolean passed
            if (doAnimation === true && !self.isMoving) {
              self.isMoving = true;
        
              var crouselPosition = ($("html").attr("dir") && $("html").attr("dir") === "rtl") ? {
                'right': newPos
              } : {
                'left': newPos
              };
              self.carouselList
                .animate(crouselPosition, {
                  duration: animDuration,
                  complete: function() {
                    self.carouselPos = newPos;
                    self.setOnStageItem(targetItemIndex);
                    self.isMoving = false;
                    // triggered onStage event for edge cases (first / last element)
                    $(self.items[targetItemIndex]).trigger('onStage');
                  }
                });
            } else {
              var crouselPosition = ($("html").attr("dir") && $("html").attr("dir") === "rtl") ? {
                'right': newPos
              } : {
                'left': newPos
              };
              this.carouselList.css(crouselPosition);
              this.carouselPos = newPos;
              this.setOnStageItem(targetItemIndex);
              // triggered onStage event for edge cases (first / last element)
              $(self.items[targetItemIndex]).trigger('onStage');
            }
          },
          /**
           * initialise stage context
           * sets all related thresholds and position offsets to handle
           * carousel stage in different context and orientation
           */
          setStageContext: function() {
            var self = this,
              stageOffset, refImage, refCanvas;
            this.stageWidth = $('.carousel-inner').width();
            $('.carousel-inner li').width(this.stageWidth);
        
            if (heroCarouselProp.infiniteMode) {
              self.maxCarouselPos = this.stageWidth * (this.itemsCount * 2) * (-1);
              self.minCarouselPos = this.stageWidth * (this.itemsCount - 1) * (-1);
            } else {
              self.maxCarouselPos = this.stageWidth * (this.itemsCount - 1) * (-1);
              self.minCarouselPos = 0;
            }
        
            this.moveTo(this.onStageItemIndex, 0, false);
        
          },
        
        }
        
        $(function() {
          mycarousel.init();
        })
        
            </script
</body>
</html>